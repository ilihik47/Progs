# Лапшин Илья 432 группа домашнее задание №3
import math as mt
import matplotlib.pyplot as plt
import numpy as np

def first():
    #             ЗАДАНИЕ №1 МЕТОД ДИХОТОМИИ И ХОРД 
    #3*x^4+4*x^3-12*x^2-7=0
    #аналитически получанны следующие корни:
        #x1=-2.84227595522777
        #x2=1.638410997485
        #два другие корня имеют комплексное значение
        #x3,4=-0.064759-+i*0.7048740
    print('аналитически получанны следующие корни:') 
    print('    x1=-2.84227595522777')
    print('    x2=1.638410997485')
    print('    два другие корня имеют комплексное значение:')
    print('    x3,4=-0.064759-+i*0.704874')
    print()  
    
    print('Введите исследуемый отрезок:')
    print()
    print('введите а')
    a=int(input())
    print()
    print('введите b')
    b=int(input())
    
    
    #                        МЕТОД ДИХОТОМИИ
    def F(x):
       f=3*x**4+4*x**3-12*x**2-7
       return f
    e=10**(-4) #погрешность #какое-то значение функции
    ff=e+1
    k=0 #количество итераций
    #a=0; b=3 #начальные концы отрезка
    while abs(ff) > e: #abs - модуль, что бы сравнивать значение функции с ошибкой
        fa=F(a) #значение в точке а
        fb=F(b) #значение в точке b
        c=(a+b)/2 #нахождение с
        ff=F(c) #значение в точке с
        fac=fa*ff 
        fcb=ff*fb
        #отбрасывание ненужного отрезка
        if fcb<0: 
            a=c
        if fac<0:
            b=c
        k=k+1
        if k>100:
            break
    if k<100:
        print('МЕТОД ДИХОТОМИИ')
        print('количество итераций:', k)
        print('значение функции:',ff)
        print('значение переменной:',c)
        print()
    
    #                           МЕТОД ХОРД
    def F(x):
       f=3*x**4+4*x**3-12*x**2-7
       return f
    e=10**(-4) #погрешность #какое-то значение функции
    ff=e+1
    k=0 #количество итераций
    #a=0; b=3 #начальные концы отрезка
    while abs(ff) > e:
        fa=F(a) #значение в точке а
        fb=F(b) #значение в точке b
    #уравнение прямой проходящей через 2 точки имеет вид:
    #       (x-x1)/(x2-x1)=(y-y1)/(y2-y1)
    #выражая х получим:х=(((y-y1)*(x2-x1))/(y2-y1))+x1
    #точка с - точка пересечения прямой с осью абсцисс (y=0)
        c=(((0-fa)*(b-a))/(fb-fa))+a # нахождение с
        ff=F(c) #значение в точке с
        fac=fa*ff 
        fcb=ff*fb
        #отбрасывание ненужного отрезка
        if fcb<0: 
            a=c
        if fac<0:
            b=c
        k=k+1
        if k>100:
            break

    if k<100:
        print('МЕТОД ХОРД')
        print('количество итераций:', k)
        print('значение функции:',ff)
        print('значение переменной:',c)
        print()
    else:
        print()
        print('на исследуемом отрезке нет пересечения функции с у=0')
        print()



def second():
    print('ЗАДАНИЕ №2 ПРОСТАЯ ИТЕРАЦИЯ И ИТЕРАЦИЯ НЬЮТОНА')
    print('введите начальную точку')
    xx=int(input()) #начальная точка
    #                   ЗАДАНИЕ №2 ПРОСТАЯ ИТЕРАЦИЯ И ИТЕРАЦИЯ НЬЮТОНА
    #f=(x-3)*cos(x)-1  
    #производная этой функции имеет вид: f=cos(x)-(x-3)*sin(x)
    
    #                            МЕТОД НЬЮТОНА
    def F(x):
        F=(x-1)*mt.cos(x)-1
        return F #значение функции в точке
    
    def f(x):
        f=mt.cos(x)-(x-3)*mt.sin(x)
        return f #значение производной функции в точке
    
    e=10**(-4) #ошибка погрешности
    x=xx #начальная точка от которой будем двигаться 
    FF=F(x)
    k=0
    while abs(FF) > e:
        FF=F(x) #значение функции в точке
        ff=f(x) #значение производной функции в точке
        x=x-(FF/ff) #нахождение новой точки 
        k=k+1
        if k>200:
            break
    if k<200:
        print('МЕТОД НЬЮТОНА')
        print('количество итераций:', k)
        print('значение функции:',FF)
        print('значение переменной:',x)
        print()
    else:
        print('методом Ньютона точку найти не удалось')
    y1=[] 
    x1=[]   
    #найдем корни графически
    k=x-4
    while k<= x+4: #для того, чтобы точнее определить точку по графику нужно сузить отображаемый отрезок
        x1.append(k)
        y1.append((k-3)*mt.cos(k)-1)
        k=k+0.1
    fig, ax = plt.subplots()
    ax.plot(x1,y1,color='red')
    ax.minorticks_on()
    ax.grid(which='major',color='black')
    ax.grid(which='minor')        
    
    #                              МЕТОД ПРОСТЫХ ИТЕРАЦИЙ
    
    def F(x):
        F=(x-1)*mt.cos(x)-1
        return F #значение функции в точке  
        
    def f(x):
        f=mt.cos(x)-(x-3)*mt.sin(x)
        return f #значение производной(касательной) в точке
       
    e=10**(-4)
    x=xx #начальная точка
    ff=f(x) # в этом методе касательная всегда одна и та же
    k=0
    FF=F(x) 
    while abs(FF) > e:
        FF=F(x)
        x=x-(FF/ff)
        k=k+1
        if k>200:
            break
    if k<200:
        print('МЕТОД ПРОСТЫХ ИТЕРАЦИЙ')
        print('количество итераций:', k)
        print('значение функции:',FF)
        print('значение переменной:',x)
        print()
    else:
        print('методом Простых итераций точку найти не удалось')
        
      
#            ЗАДАНИЕ №3      РЕШЕНИЕ СИСТЕМЫ УРАВНЕНИЙ МЕТОДОМ НЬЮТОНА
print('ЗАДАНИЕ №3  РЕШЕНИЕ СИСТЕМЫ УРАВНЕНИЙ МЕТОДОМ НЬЮТОНА')
def third():
    x=1;y=1 #задаем начальные точки
    e=10**(-4) #ошибка погрешности из задания 
    f1=x**2+y**2-1 #найдем значения функций в начальных точках
    f2=x-y**3-0.5
    k=0 #отсчет количества итераций
    while abs(f1)>e or abs(f2)>e:
        f1=x**2+y**2-1
        f2=x-y**3-0.5
        f=np.zeros((2,1)) #массив(матрица) в котором будут храниться значения функций в точке (х,у)
        f[0,0]=f1
        f[1,0]=f2
        f11=2-x
        f21=1
        f12=2*y
        f22=-3*y**2       
        ff=np.zeros((2,2)) #массив(матрица) в котором будут храниться значения частных производных функций 
        ff[0,0]=f11 #fij , где i номер функции, j переменная по которой дифференцируют 1-x 2-y
        ff[0,1]=f12 #                                   
        ff[1,0]=f21
        ff[1,1]=f22
        ff=np.linalg.inv(ff) #обратная матрица частных производных
        c=-np.matmul(ff,f) # смещение по х и y (новые начальные точки)
        k=k+1
        x=x+c[0,0] #новый х
        y=y+c[1,0] #новый у
    print('МЕТОД НЬЮТОНА ДЛЯ СИСТЕМЫ УРАВНЕНИЙ')
    print('количество итераций:', k)
    print('значение 1-ой функции:',f1)
    print('значение 2-ой функции:',f2)
    print('значение переменной х:',x)
    print('значение переменной y:',y)






first()
second()
third()














    
    
     
    
    
    