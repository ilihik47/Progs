'Решить методами Гаусса и Гаусса-Зейделя, найти λmin,λmax, '
'определить число обусловленности матрицыμ=‖A‖·‖A−1‖. '
'Сделать вывод нормы вектора невязки для обоих методов. '
import numpy as np
#задаю матрицу коэффициентов и матрицу правых частей уравнения
plpl=100 #размерность матрицы(вводил для удобства проверки кода на матрицах меньшего размера)
def matrix():
    f=np.zeros((plpl,1)) #массив, который будет содержать правую часть уравнений
    A=np.zeros((plpl,plpl)) #массив, который будет будет содержать матрицу коэффициентов
    n=len(A)
    for i in range(n):
        f[i][0]=i+1 #построчно задаю значения правой части
        for j in range(n):
            if j==i:
                if j==n-1:
                    A[i][j]=100 #задание самого последнего элемента i=j=100
                else:
                    A[i][j]=100 #задание элемента на главной диагонали и последующего элемента в строке
                    A[i][j+1]=1/(1+i)
                    break #завершаю внутренний цикл и перехожу к следующей строчке 
            else:
                A[i][j]=1/(1+i)
    return A,f #функция возвращает две матрицы(два массива)

           
def gauss(): #функция, решающая систему методом Гаусса
    A=matrix()[0] #ввожу в функцию выведенные ранее матрицы
    f=matrix()[1]
    n=len(A)
    for i in range(n): #привожу матрицу коэффициентов к ступенчатому виду
        a=A[i][i] #задаю опорный элемент(решил, что всегда на главное диагонали, так удобнее)
        A[i]=A[i]/a #делю строку на этот опорный элемент, дабы получить 1
        f[i]=f[i]/a
        j=i+1
        while j<=n-1: #нужно занулить элемент под опорным
            c=A[j][i] #чтобы сделать 0, нужно домножить исследуюемую строку на элемент под опорным 
            f[j]=f[j]-f[i]*c # и вычесть из следующей получивщуюся исследуемую 
            A[j]=A[j]-A[i]*c
            j=j+1
    
    X=np.zeros(n) #матрица будующих значений переменных
    
    for i in range(len(f) - 1, -1, -1): # после приведения получилось, что 100-ый х я уже знаю
    # буду подставлять этот 100-ый х в 99 строку, так найду 99-ый х. И так далее
            X[i]=f[i] - sum(x * a for x, a in zip(X[(i + 1):], A[i][(i + 1):]))
    return X # функция возвращает матрицу переменных



def norma(A):#функция, считающая норму матрицы
    c=A.shape #введу размерность матрицы 
    a=np.zeros(c[0]) # массив, который будет содержать сумму коэффициентов строки
    if len(c)>1: #для матрицы у которой больше 1 столбцов
        for j in range(c[1]):  #по строчкам
            for i in range(c[0]): #по столбцам
                a[j]=a[j]+A[i][j] #суммирование коэффициентов в строке
    else:
        for i in range(len(A)): #для матрицы у которой 1 столбец
            a[i]=a[i]+A[i]
    m=max(a) # норма-максимальная сумма из получившихся 
            
    return m #функция выводит число
    
    
def seidel(e): #функция, решающая систему методом Гаусса-Зейделя
    A=matrix()[0] #ввожу в функцию выведенные ранее матрицы
    f=matrix()[1]
    n = len(A)
    x = np.zeros(n) #матрица будующих значений переменных
    s1=s2=0 #начальные суммы равны 0
    ysl = False #сначала условие окончания не выполняется
    while not ysl:
        l =x
        for i in range(n):
            s1=s2=0 #при переходе на новую строку сумма обнуляется
            for j in range(i): #сумма элементов до i-того
                s1=s1+A[i][j]*l[j]
            for j in range(i + 1, n): #сумма элементов после i-того
                s2=s2+A[i][j]*x[j]                     
            l[i] = (f[i] - s1 - s2) / A[i][i]
            

        ysl = norma(l-x) <= e #условие окончания
        x = l

    return x # функция возвращает матрицу переменных 



def chisla(): #функция находит минимальное и максимальное собственные числа матрицы
    A=matrix()[0] #ввожу в функцию выведенную ранее матрицу
    l=np.linalg.eigvalsh(A) #массив всех собственных чисел
    l1=min(l) #отбор минимального
    l2=max(l) #отбор максимального
    return l1, l2 #функция возвращает два числа
    

def chislo_obyslovlennosti(): #функция находит число обусловленности матрицы
    A=matrix()[0] #ввожу в функцию выведенные ранее матрицы
    f=matrix()[1]
    a=np.linalg.inv(A) # делаю обратную матрицу
    h=norma(A)*norma(a) #нахожу по формуле число обусловленности, как произведение норм обычной и обратной матриц
    return h #функция возвращает число 

      
def neiavka():
    A=matrix()[0] #ввожу в функцию выведенные ранее матрицы
    f=matrix()[1]
    n=len(A)
    c=A.shape #ввожу размерность матрицы
    g=np.zeros((plpl,1)) #матрица, которая будет содержать левую часть с подставленными переменными для метода Гаусса
    z=np.zeros((plpl,1))#матрица, которая будет содержать левую часть с подставленными переменными для метода Гаусса-Зейделя
    G=gauss() #введу значения переменных для метода Гаусса
    S=seidel(10**(-3)) #введу значения переменных для метода Гаусса-Зейделя
    for i in range(c[0]): #подставляю значения и считаю левую часть
        s1=s2=0
        for j in range(c[1]):
            s1=s1+A[i][j]*G[j]
            s2=s2+A[i][j]*S[j]
        g[i][0]=s1
        z[i][0]=s2
    Nz=np.zeros((plpl,1))
    Ng=np.zeros((plpl,1))
    for i in range(n): #нахожу разницу между полученной левой частью и исходной
        Nz[i][0]=f[i][0]-z[i][0]
        Ng[i][0]=f[i][0]-g[i][0]
    Ng=norma(Ng) #нормы векторов невязки, для обоих методов
    Nz=norma(Nz)
    return Ng,Nz #функция возвращает два числа
print('Неизвестные полученные методом Гаусса:')
print(gauss())
print()
print('Неизвестные полученные методом Гаусса-Зейделя:')
print(seidel(10**(-6)))
print()
print('Максимальное и минимальное собственные числа матрицы:')
print('min=',chisla()[0],'max=',chisla()[1])
print()
print('Число обусловленности матрицы:')
print(chislo_obyslovlennosti())
print()
print('Нормы вектора невязки для обоих методов:')
print('Гаусс:',neiavka()[0],'Гаусс-Зейдель:',neiavka()[1])
print()

    


        
        
        
        
        
        

        
        
        
        
        
        
        